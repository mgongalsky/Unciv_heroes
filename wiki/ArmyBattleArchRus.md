# Обзор архитектуры и взаимодействия классов

Проект построен на основе архитектурного паттерна **Model-View-Controller (MVC)**, который разделяет логику, визуальное представление и взаимодействие с пользователем на отдельные компоненты. Основные принципы, которые мы используем:

1. **Разделение ответственности**:
   Каждый класс выполняет строго определённую задачу, что позволяет чётко разделять данные, логику и визуализацию.

2. **Модульность**:
   Классы спроектированы для повторного использования и удобного тестирования, минимизируя зависимость между компонентами.

3. **Масштабируемость**:
   Архитектура позволяет легко добавлять новые функции без нарушения существующей структуры.

4. **Гибкость**:
   Классы взаимодействуют через чётко определённые интерфейсы и объекты (например, `BattleActionRequest`, `BattleActionResult`), что облегчает замену или расширение компонентов.

Система разделена на два основных подсистемы:
1. **Управление армией и её отображение**
   Отвечает за визуализацию и логику управления армиями и войсками вне битвы.
2. **Система битвы**
   Реализует механику битв, включая взаимодействие войск, логику ИИ и завершение битвы.

---

## 1. Управление армией и её отображение

Эта подсистема занимается организацией и отображением армий в пользовательском интерфейсе, а также операциями управления войсками, такими как добавление, удаление, обмен и разделение войск.

### **Ключевые классы**
1. **[CityScreen](#)**
    - **Роль**: Отображает армии внутри города. Это основной интерфейс для взаимодействия с армиями в мирное время.
    - **Взаимодействие**: Использует `ArmyView` для отображения армий и `TroopArmyView` для отдельных войск.

2. **[ArmyManager](ArmyManagerRus.md)**
    - **Роль**: Обеспечивает логику управления двумя армиями, включая добавление, удаление, обмен, объединение и разделение войск.
    - **Взаимодействие**: Работает с экземплярами `ArmyInfo` для выполнения операций.

3. **[ArmyInfo](#)**
    - **Роль**: Логическое представление армии. Хранит информацию о войсках и выполняет низкоуровневые операции, такие как добавление или удаление войск.
    - **Взаимодействие**: Используется в `ArmyManager` и `BattleManager`.

4. **[TroopInfo](#)**
    - **Роль**: Представляет одно войско логически, включая его тип, количество и свойства.
    - **Взаимодействие**: Используется в `ArmyInfo` для управления войсками и в `BattleManager` во время битвы.

5. **[TroopArmyView](#)**
    - **Роль**: Визуальное представление отдельного войска в армии, отображаемое в интерфейсе армии.
    - **Взаимодействие**: Используется в `ArmyView` для отображения деталей отдельного войска.

6. **[ArmyView](#)**
    - **Роль**: Обеспечивает визуальное представление всей армии. Организует несколько экземпляров `TroopArmyView` и предлагает взаимодействие для управления войсками.
    - **Взаимодействие**: Обращается к `ArmyManager` для выполнения логических операций и к `TroopArmyView` для рендера войск.

---

## 2. Система битвы

Эта подсистема реализует механику битвы, включая логику действий, визуализацию и принятие решений ИИ.

### **Ключевые классы**
1. **[BattleScreen](BattleScreenRus.md)**
    - **Роль**: Обеспечивает визуальный интерфейс битвы. Обрабатывает взаимодействие пользователя и обновляет позиции войск на поле боя.
    - **Взаимодействие**: Использует `BattleManager` для логики битвы и `TroopBattleView` для отображения войск.

2. **[BattleManager](BattleManagerRus.md)**
    - **Роль**: Содержит логику битвы, включая управление ходами, действиями войск и завершением битвы.
    - **Взаимодействие**: Обменивается данными с `BattleScreen` для визуального обновления и использует `ArmyInfo` и `TroopInfo` для логики.

3. **[AIBattle](#)**
    - **Роль**: Управляет действиями войск, контролируемых ИИ, во время битвы.
    - **Взаимодействие**: Работает с `BattleManager` для принятия решений и выполнения действий ИИ.

4. **[TroopBattleView](#)**
    - **Роль**: Визуальное представление войска во время битвы. Отображает действия войск, такие как перемещение и атака.
    - **Взаимодействие**: Управляется `BattleScreen` и взаимодействует с тайлами поля боя.

5. **[TroopInfo](#)**
    - **Роль**: То же, что и в подсистеме управления армией, но используется здесь для отслеживания состояния войск в битве.
    - **Взаимодействие**: Доступен из `BattleManager` для логики действий.

6. **[ArmyInfo](#)**
    - **Роль**: То же, что и в подсистеме управления армией, но используется здесь для управления армиями, участвующими в битве.
    - **Взаимодействие**: Предоставляет данные `BattleManager`.

---

## 3. Вспомогательные классы для коммуникации

Для обмена данными между компонентами используются следующие промежуточные классы:

1. **BattleActionRequest**
    - **Назначение**: Представляет запрос на действие (например, перемещение, атаку), отправленный игроком или ИИ.
    - **Использование**: Передаётся от `BattleScreen` в `BattleManager`.

2. **BattleActionResult**
    - **Назначение**: Представляет результат действия войска (например, успех или провал).
    - **Использование**: Возвращается `BattleManager` в `BattleScreen` для обновления интерфейса.

3. **BattleTotalResult**
    - **Назначение**: Представляет общий результат битвы, включая победившую армию.
    - **Использование**: Генерируется `BattleManager` в конце битвы.

---

## Применение паттерна MVC

- **Модель (Model)**:
    - `ArmyInfo`, `TroopInfo` для логики армии и войск.
    - `BattleManager` и `AIBattle` для логики битвы.

- **Представление (View)**:
    - `ArmyView` и `TroopArmyView` для интерфейса армии.
    - `BattleScreen` и `TroopBattleView` для интерфейса битвы.

- **Контроллер (Controller)**:
    - `ArmyManager` для управления взаимодействием войск между армиями.
    - `BattleManager` для обработки действий войск в битве.

---

Эта архитектура обеспечивает чёткое разделение ответственности, делая систему модульной, удобной для поддержки и масштабируемой.
